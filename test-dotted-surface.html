<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DottedSurface Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: white;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>DottedSurface Test</h3>
        <p id="status">Initializing...</p>
        <p id="particles">Particles: 0</p>
        <p id="fps">FPS: 0</p>
    </div>
    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const container = document.getElementById('container');
        const statusEl = document.getElementById('status');
        const particlesEl = document.getElementById('particles');
        const fpsEl = document.getElementById('fps');

        try {
            statusEl.textContent = 'Creating scene...';

            const SEPARATION = 150;
            const AMOUNTX = 40;
            const AMOUNTY = 60;

            // Scene setup
            const scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xffffff, 2000, 10000);

            const camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                1,
                10000
            );
            camera.position.set(0, 355, 1220);

            const renderer = new THREE.WebGLRenderer({
                alpha: true,
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(scene.fog.color, 0);

            container.appendChild(renderer.domElement);
            statusEl.textContent = 'Canvas created';

            // Create particles
            const positions = [];
            const colors = [];
            const geometry = new THREE.BufferGeometry();

            for (let ix = 0; ix < AMOUNTX; ix++) {
                for (let iy = 0; iy < AMOUNTY; iy++) {
                    const x = ix * SEPARATION - (AMOUNTX * SEPARATION) / 2;
                    const y = 0;
                    const z = iy * SEPARATION - (AMOUNTY * SEPARATION) / 2;

                    positions.push(x, y, z);
                    colors.push(0, 0, 0); // Black particles
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 12,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            particlesEl.textContent = `Particles: ${AMOUNTX * AMOUNTY}`;
            statusEl.textContent = 'Animating...';

            let count = 0;
            let frameCount = 0;
            let lastTime = performance.now();

            // Animation
            function animate() {
                requestAnimationFrame(animate);

                const positionAttribute = geometry.attributes.position;
                const positions = positionAttribute.array;

                let i = 0;
                for (let ix = 0; ix < AMOUNTX; ix++) {
                    for (let iy = 0; iy < AMOUNTY; iy++) {
                        const index = i * 3;
                        positions[index + 1] =
                            Math.sin((ix + count) * 0.3) * 50 +
                            Math.sin((iy + count) * 0.5) * 50;
                        i++;
                    }
                }

                positionAttribute.needsUpdate = true;
                renderer.render(scene, camera);
                count += 0.1;

                // FPS counter
                frameCount++;
                const currentTime = performance.now();
                if (currentTime >= lastTime + 1000) {
                    fpsEl.textContent = `FPS: ${frameCount}`;
                    frameCount = 0;
                    lastTime = currentTime;
                }
            }

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
            statusEl.textContent = 'Running! âœ“';

        } catch (error) {
            statusEl.textContent = `Error: ${error.message}`;
            statusEl.style.color = '#ff4444';
            console.error(error);
        }
    </script>
</body>
</html>
